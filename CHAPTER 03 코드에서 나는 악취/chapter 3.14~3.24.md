3.14 성의 없는 요소

- 이전에 필요했던 부분이라도 지금은 필요없을 수 있다.

  3.15 추측성 일반화

- 나중에 필요할거야 라는 부분은 쓸데없는 낭비인 경우가 많다.
- 당장 걸리적거리는 코드는 눈앞에서 치우자.

  3.16 임시필드

간혹 특정 상황에서만 값이 설정되는 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는 게 보통이라, 이렇게 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.

- `클래스 추출하기`, `함수 옮기기` 를 통해 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아 넣는다.
- 임시 필드들이 유효한 지를 확인한 후 동작하는 조건부 로직이 있을 수 있는데, `특이 케이스 추가하기` 로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할수 있다.

  3.17 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 내비게이션 중단 단계를 수정하면 클라이언트 코드도 수정되어야 한다.

- 위임 숨기기
- `함수 추출하기` 로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 `함수 옮기기` 로 체인을 숨길 수 있는지 살펴보자.

  3.18 중개자

객체의 대표적인 기능 하나로, 캡슐화가 있다. 캡슐화하는 과정에서 위임이 자주 활용이 되는데, 하지만 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 어떤가?

- `중개자 제거하기` 를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자

  3.19 내부자 거래

모듈 사이의 데이터 거래가 많으면 결합도가 높아진다. 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

- 은밀히 데이터를 주고받는 모듈들이 있다면 `함수 옮기기` 와 필드 옮기기 기법으로 떼어놓아서 사적으로 처리하는 부분을 줄인다.
- 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제 3의 모듈을 만들거나 `위임 숨기기` 를 이용한다.

  3.20 거대한 클래스

한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다.

- 클래스 추출하기
- 슈퍼 클래스 추출하기
- 타입 코드를 서브 클래스로 바꾸기

  3.21 서로 다른 인터페이스의 대안 클래스

  3.22 데이터 클래스

데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.

- public 필드가 있다면 `레코드 캡슐화하기`
- 변경하면 안 되는 필드는 `세터 제거하기`

  3.23 상속 포기

서브 클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나 필요 없다면 어떻게 해야 할까? 수 많은 유산 중에 관심 있는 몇 개만 받고 끝내려는 경우는 얼마든지 있을 수 있다.

- `서브 클래스를 위임` 으로 바꾸기나 `슈퍼클래스를 위임` 으로 바꾸기 를 활용해서 상속 메커니즘에서 벗어나보자.

  3.25 주석

_주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다._

- **함수 선언 바꾸기**
  - 고작 이름일 뿐이지 않은가?
    - 이는 ‘혼란’이란 악마의 유혹 → 함수의 구현문을 살피기 전에 기능을 파악할 수 있는 큰 역할
  - 좋은 이름을 떠올리는데 효과적인 방법
    - 주석을 이용해 함수의 목적을 설명 → 그러다 보면 주석이 멋진 이름으로 바뀌어 되돌아올 때가 있다
  - 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의하고 함수를 사용하는 문맥을 설정
    - 지불 기한이 지났는지 판단하는 함수의 매개변수
      - 지불 객체를 매개변수로 or 마감일을 매개변수로
    → 문제의 정답은 바로 정답이 없다는 것 → 어떻게 연결하는게 더 잘 이해하게 될 때마다 코드를 개선
  - 간단한 절차 / 마이그레이션 절차
    - 간단한 절차
      - 함수 이름 바꾸기 간단한 절차
          <aside>
          💡 간단한 절차
          
          1. 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다
          2. 메서드 선언을 원하는 형태로 바꾼다
          3. 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정한다
          4. 테스트한다
          </aside>

      - 사실 웬만한 IDE에서 지원되는 기능일 듯
    - 마이그레이션 절차
      - 함수 이름 바꾸기 마이그레이션 절차
          <aside>
          💡 마이그레이션 절차
          
          1. 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다
          2. 함수 본문을 새로운 함수로 추출한다
              - 새로 만들 함수 이름이 기존 함수와 같아면 일단 검색하기 쉬운 이름을 임시로 붙여둔다
          3. 추출한 함수에 매개변수를 추가해야 한다면 ‘간단한 절차’를 따라 추가한다
              
              (때에 따라 마이그레이션 절차로 처리)
              
          4. 테스트한다
          5. 기존 함수를 인라인한다
          6. 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다
          7. 테스트한다
          </aside>

    - 예전 함수를 deprecated로 지정하고 모든 클라이언트가 새 함수로 이전할 때까지 기다리기
    - 클라이언트들이 모두 이전했다는 확신이 들면 예전 함수 삭제
  - 함수 선언 바꾸기는 공개된 API 즉, 직접 고칠 수 없는 외부 코드가 사용하는 부분을 리팩터링하기에 좋음
- **변수 캡슐화하기**
  - 배경
    - 데이터는 함수보다 다루기가 까다로움
    - 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다
      - getter/setter
    - 객체의 데이터를 항상 private으로 유지
    - 불변 데이터는 가변 데이터보다 캡슐화할 이유가 적다
  - 절차
      <aside>
      💡 절차
      
      1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
      2. 정적 검사를 수행한다.
      3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트 한다.
      4. 변수의 접근 범위를 제한한다.
      5. 테스트한다.
      6. 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.
      </aside>

  - 값 캡슐화하기
    ```tsx
    // 캡슐화 전
    class User {
      constructor(name, age, address) {
        this.name = name;
        this._age = age;
      }
    }

    const user = new User("Alice", 25);
    console.log(user.age); // 25

    user.age = -10;
    console.log(user.age); // -10

    // 캡슐화 후
    class User {
      constructor(name, age) {
        this.name = name;
        this._age = age;
        this._address = [...address]; // 복제된 배열 저장
      }

      get age() {
        return this._age;
      }
      set age(newAge) {
        if (newAge < 0) {
          console.error("나이는 0 이상");
          return;
        }
        this._age = newAge;
      }

      get address() {
        return [...this._address]; // 내부 배열의 복제본 반환
      }

      set address(newAddress) {
        this._address = [...newAddress];
      }
    }

    const user = new User("Alice", 25);
    console.log(user.age); // 25

    user.age = -10; // 유효하지 않은 값 설정 시도
    console.log(user.age); // 여전히 25
    ```
    - 데이터의 복제본을 반환하도록 → 게터로 얻은 데이터를 변경할 수 있지만 원본에 영향은 없다
    - 데이터의 사용 범위가 넓을 수록 적절히 캡슐화하는 것이 필요(전역적으로 사용이 필요할 경우)
- **변수 이름 바꾸기**
  - 배경
    - 명확한 프로그래밍의 핵심은 이름짓기다
      - 변수는 프로그래머가 하려는 일에 관해 많은 것을 설명해주나 이는 이름을 잘 지었을 때만 해당
  - 이름을 잘 못 짓는 경우
    - 고민을 충분히 하지 않아서
    - 개발을 더 하다 보니 문제에 대한 이해도가 높여저서
    - 사용자의 요구가 달라져서 프로그램의 목적이 변해서
  - 적용 시점
    - 변수 이름이 목적과 다른 경우, 명확하지 않은 경우
    - 사용 범위가 큰 변수일수록 이름이 중요하다
      - 영속적인 필드 VS 람다식의 변수
        ```tsx
        // 영속적 필드
        class User {
          private userName: string; // 이름이 명확해야 함
        }
        // 람다식 변수
        const square = (x) => x * x; // 이름 간단
        ```
  - **절차**
    1. 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다.
    2. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다.
    3. 테스트한다
- **매개변수 객체 만들기**
  - 배경
    - 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해짐
    - 매개변수의 수가 줄어든다
    - 데이터구조를 활용하도록 프로그램 동작을 재구성하기 때문에 코드를 더 근본적으로 바꿔준다
  - 절차
    1. 적당한 구조가 없으면 새로 만든다 (클래스나 구조체)
    2. 테스트한다
    3. "함수 선언 바꾸기"로 새 데이터 구조를 매개변수로 추가한다
    4. 테스트한다
    5. 함수 호출 시 새 구조 인스턴스를 넘기도록 수정한다. 하나씩 하면서 테스트한다.
    6. 기존 매개변수를 사용하던 코드에서 새 구조의 원소를 사용하도록 한다.
    7. 다 바꿨으면 기존 매개변수를 삭제하고 테스트한다.
  - ex.
    ```tsx
    function readingOutsideRange(station, min, max) {
      return station.readings.filter((r) => r.temp < min || r.temp > max);
    }

    // --> 절차 수행
    class NumberRange {
      constructor(min, max) {
        this._data = { min: min, max: max };
      }
      get min() {
        return this._data.min;
      }
      get max() {
        return this._data.max;
      }
    }

    function readingOutsideRange(station, range) {
      return station.readings.filter(
        (r) => r.temp < range.min || r.temp > range.max
      );
    }
    ```

- 1.1 자, 시작해보자! - 정리할 내용 없음
- 1.2 예시 프로그램을 본 소감
    
    신규 기능을 추가하거나 코드를 수정하기 어렵다면 코드 리픽터링을 먼저하자
    
    가독성이 좋아야 코드 유지보수도 쉽다
    
- 1.3 리팩터링의 첫 단계
    
    리팩터링 시 가장 기본적인 1단계 ⇒ 테스트 코드 작성하기
    
    ### 테스트 코드
    
    성공, 실패를 바탕으로 한 테스트 코드 즉, 상태 테스트 코드가 추가되어야 리팩터링 작업을 보장할 수 있다.
    
    <aside>
    💡 (뒤에서 나오지만) 리팩터링의 기본은 수정되기 전과 후의 코드가 동일하게 동작해야한다.
    
    </aside>
    
    <aside>
    💡 깨지기 쉬운 상호작용 테스트 보다는 상태 테스트 코드를 작성하도록 하자.
    - 상호작용 테스트 → 기대한 동작이 수행되었는가?   ex) 메소드가 기대한 횟수만큼 호출되었는가?
    - 상태 테스트 → 기대한 결과 값을 도출하였는가?   ex) 메소드가 기대한 값을 도출하였는가?
    
    </aside>
    
    ### 테스트 코드 장점
    
    - 디버깅 시간을 줄인다 ⇒ 생산성 향상
    - 실수를 줄인다 ⇒ 비용 절감
    
    +특히나 다른 API에 영향이 가는지 여부도 테스트 코드를 통해 확인할 수 있어 유용하다.
    
- 1.4 statement() 함수 쪼개기
    
    저자가 작업한 statement() 함수 리팩토링 작업이 예시로 나옵니다.
    
    자세한 예시는 책에서 읽는 것으로 하고 중요한 포인트만 정리하자면,
    
    ### 리팩터링 방법
    
    길고 여러 행위가 섞여있는 메소드를 리팩토링 한다면 아래 1,2,3 번을 반복하여 수행한다.
    
    1. 분리가 가능한 메소드 추출하기
        1. 긴 코드 내에서 분리가 가능한 기능을 추출하여 가능한 작은 단위로 쪼갭니다.
        2. 이 때 처음부터 모든 코드를 쪼개는 것이 아니라 가능한 기능부터 작게 추출합니다.
        - example
            - AS-IS
                
                ```json
                /* 공연료 청구서를 출력하는 메서드 */
                function statement(invoice, plays){
                    // 공연 장르 별로 공연료를 산출한다.
                    // 포인트를 적립한다.(다음번 공연 시 공연 할인)
                    // 희극인 경우 관객 5명마다 추가 포인트를 제공한다.
                    // 청구 내역을 출력한다.
                }
                ```
                
            - TO-BE
                
                ```json
                /* 공연료 청구서를 출력하는 메서드 */
                function statement(invoice){
                    amountFor(..);
                	  // 포인트를 적립한다.(다음번 공연 시 공연 할인)
                    // 희극인 경우 관객 5명마다 추가 포인트를 제공한다.
                    // 청구 내역을 출력한다.
                }
                
                /* 공연료를 산출하는 메서드 */
                function amountFor(plays){
                    // 공연 장르 별로 공연료를 산출한다.
                }
                ```
                
    2. 작성한 테스트 코드 실행하기
        1. 수정 전과 후의 코드가 동일하게 동작하는 지 확인한다.
    3. 매개변수와 반환 값 등의 네이밍에서 의미가 명확하게 드러나도록 수정하기
        1. 각각의 역할이 명확하게 드러나야한다.
        2. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다
    
    <aside>
    💡 결국, 컴파일 - 테스트 - 커밋 순으로 반복하면서 리팩터링을 수행한다.
    
    코드가 복잡할 수록 작은 단계로 작업을 반복하며 커밋하면 작업 속도가 빨라진다.
    커밋 후 다음 리팩터링 시 테스트 케이스를 통과하지 못한다면 이전 커밋으로 바로 돌아가면 된다.
    
    </aside>
    
    ### 인상 깊었던 예시 중 하나 - 반복문 쪼개기(44p - 47p)
    
    - example
        
        포인트 적립 및 청구 내역을 출력하는 기능
        
        ```json
        /* 공연료 청구서를 출력하는 메서드 */
        function statement(invoice, plays){
            ...
            // 포인트를 적립한다.(다음번 공연 시 공연 할인)
            // 청구 내역을 출력한다.
        }
        ```
        
        - AS-IS
            
            ```json
            function statement(invoice, plays){
            		...
            		// 하나의 for문 안에서 두 가지 기능을 수행한다.
            		for(let pref of invoice.performances){
            				// 포인트를 적립한다.
            				credits += volumeCreditsFor(pref);
            				
            				// 청구 내역을 출력한다.
            				result += `${playFor(pref).name} : ${usd(amountFor(pref))}`
            		}
            }
            ```
            
        - TO-BE
            
            ```json
            function statement(invoice, plays){
            		...
            		// => 반복문을 쪼갰다
            		for(let pref of invoice.performances){
            				// 포인트를 적립한다.
            				credits += volumeCreditsFor(pref);
            		}
            		
            		for(let pref of invoice.performances){
            				// 청구 내역을 출력한다.
            				result += `${playFor(pref).name} : ${usd(amountFor(pref))}`
            		}
            }
            ```
            
    
    반복문이 중복되는 것이 꺼릴 수 있지만, 적당한 중복은 성능에 미치는 영향이 미미할 때가 많다.
    
    소프트웨어 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정된다.
    
    ### 리팩터링 = 성능 개선?
    
    NO🙅‍♀️
    
    리팩터링의 주된 목적은 구조 개선이다.
    
    리팩터링 후 성능이 기존보다 떨어졌다면 리팩터링 이후에 개선하면 된다.
    
    구조가 개선되어야지 성능 개선 작업을 더 효과적으로 할 수 있다.
    
    정말 특별한 경우가 아니라면 일단 무시하자.